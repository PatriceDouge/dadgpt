# DadGPT Implementation Progress

## Codebase Patterns
<!-- Reusable patterns discovered during implementation - add here as you learn -->
- Use pnpm (not bun) for all package management
- Use node:fs/promises for file operations (not Bun APIs)
- Use vitest for testing (import from "vitest")
- Use tsx for TypeScript execution
- Storage files go in ~/.dadgpt/data/
- All IDs are ULIDs for sortability
- Use namespace pattern for utility modules (Log, Storage, Bus, etc.)

---

## Progress Log

<!-- Append progress entries below this line -->

## 2026-01-13 - P1-001
- What was implemented: Created package.json with all required dependencies and devDependencies
- Files changed: package.json, pnpm-lock.yaml, .gitignore (new)
- **Learnings for future iterations:**
  - pnpm install works correctly with specified versions
  - Added .gitignore to exclude node_modules/, dist/, coverage/, .env, *.log
---

## 2026-01-13 - P1-002
- What was implemented: Created TypeScript configuration for the project
- Files changed: tsconfig.json (new), src/index.ts (new - minimal entry point)
- **Learnings for future iterations:**
  - moduleResolution "bundler" works well with ES modules and tsx
  - Need at least one .ts file in src/ for typecheck to work (otherwise error about no inputs)
  - noUncheckedIndexedAccess adds extra safety for array/object access
---

## 2026-01-13 - P1-003
- What was implemented: Created Vitest configuration for running tests
- Files changed: vitest.config.ts (new), test/unit/placeholder.test.ts (new)
- **Learnings for future iterations:**
  - vitest.config.ts uses defineConfig from "vitest/config"
  - Test files go in test/ directory with pattern **/*.test.ts
  - Created placeholder test to verify configuration works
  - Coverage reports to text, json, and html formats
---

## 2026-01-13 - P1-004
- What was implemented: Created CLI entry point for dadgpt command
- Files changed: bin/dadgpt (new), src/index.ts (updated)
- **Learnings for future iterations:**
  - bin/dadgpt uses `import("tsx/esm").then(() => import("../src/index.ts"))` pattern for tsx
  - File must be executable (chmod +x) to work as CLI entry
  - pnpm dev runs tsx src/index.ts directly for development
---

## 2026-01-13 - P1-005
- What was implemented: Created ID generation utility using ULID
- Files changed: src/util/id.ts (new), eslint.config.js (new), package.json (eslint deps added)
- **Learnings for future iterations:**
  - ESLint 9 requires flat config file (eslint.config.js) with @eslint/js and typescript-eslint packages
  - ulid package provides ULID generation - IDs are lexicographically sortable by timestamp
  - Utility modules go in src/util/ directory
---

## 2026-01-13 - P1-006
- What was implemented: Created logging utility with configurable log levels
- Files changed: src/util/log.ts (new), eslint.config.js (updated)
- **Learnings for future iterations:**
  - PRD requires namespace pattern for Log utility - disabled @typescript-eslint/no-namespace rule
  - Log levels follow hierarchy: DEBUG > INFO > WARN > ERROR (debug is most verbose)
  - warn() and error() always log regardless of configured level
---

## 2026-01-13 - P1-007
- What was implemented: Created custom error types for better error handling
- Files changed: src/util/errors.ts (new)
- **Learnings for future iterations:**
  - Error classes extend base DadGPTError which extends Error
  - Each error type has a `code` property for programmatic error identification
  - Use Error.captureStackTrace when available to maintain proper stack traces
  - Error types: ConfigError, StorageError, ProviderError, ToolError
---

## 2026-01-13 - P1-008
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented: Created storage path utilities module
- Files changed: src/storage/paths.ts (new)
- **Learnings for future iterations:**
  - Use node:path and node:os imports (with node: prefix for clarity)
  - DADGPT_DATA_DIR env var allows overriding data directory for testing
  - DADGPT_HOME env var allows overriding home directory
  - Path constants are computed via functions to support env override
  - getDataPath() auto-appends .json extension
  - Storage layer lives in src/storage/ directory
---

## 2026-01-13 - P1-009
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented: Created Storage namespace with CRUD operations for JSON file persistence
- Files changed: src/storage/storage.ts (new)
- **Learnings for future iterations:**
  - Use node:fs/promises (not Bun APIs) for file operations
  - Storage namespace pattern matches other utility modules (Log, Bus, etc.)
  - Storage.read<T>() returns undefined (not null) when file not found
  - Storage.write() uses JSON.stringify with null, 2 for pretty printing
  - Storage.update() provides atomic read-modify-write operation
  - Storage.list() returns filenames without .json extension
  - Must import os from "node:os" at top level - cannot use require() in ESM
---

## 2026-01-13 - P1-010
- What was implemented: Created comprehensive unit tests for the Storage layer
- Files changed: test/unit/storage.test.ts (new)
- **Learnings for future iterations:**
  - Use DADGPT_DATA_DIR env var to override data directory for testing
  - Create unique temp directories per test to avoid conflicts: `${os.tmpdir()}/dadgpt-test-${Date.now()}-${random}`
  - Clean up temp directories in afterEach with fs.rm(dir, { recursive: true, force: true })
  - Tests verify: write/read roundtrip, read non-existent, update creates/modifies, list files, remove, exists, ensureDir
---

## 2026-01-13 - P1-011
- What was implemented: Created Event Bus pub/sub system for decoupled communication
- Files changed: src/bus/bus.ts (new)
- **Learnings for future iterations:**
  - Bus namespace follows same pattern as Log, Storage modules
  - Handler Map stores Set<Handler<unknown>> to support multiple handlers per event
  - publish() wraps each handler call in try/catch so errors don't break other handlers
  - subscribe() returns an unsubscribe function for cleanup
  - Events object provides type-safe event definitions with payload types
  - EventName and EventPayload<E> types exported for type-safe usage
---

## 2026-01-13 - P1-012
- What was implemented: Created comprehensive unit tests for the Event Bus
- Files changed: test/unit/bus.test.ts (new)
- **Learnings for future iterations:**
  - Use vi.spyOn(console, "error").mockImplementation(() => {}) to suppress expected console output in tests
  - Bus.clear() in beforeEach ensures test isolation between tests
  - Test that publish to non-existent event doesn't throw
  - Test that payload reference is preserved (same object, not copied)
---

## 2026-01-13 - P2-001
- What was implemented: Created Zod schemas for configuration validation
- Files changed: src/config/schema.ts (new)
- **Learnings for future iterations:**
  - Config files go in src/config/ directory
  - Zod schemas provide both runtime validation and TypeScript type inference
  - Use z.infer<typeof Schema> to extract types from Zod schemas
  - Default values in schemas using .default() method
  - Export both schemas and inferred types for maximum flexibility
---

## 2026-01-13 - P2-002
- What was implemented: Created default configuration values for DadGPT
- Files changed: src/config/defaults.ts (new)
- **Learnings for future iterations:**
  - Import types with `import type` for type-only imports
  - DEFAULT_CONFIG is typed as Config from schema.ts for type safety
  - Default permissions: allow read-only tools (read, goal, todo, project, family), ask for write/bash
  - goalCategories default to Health, Family, Work, Personal, Finance
---

## 2026-01-13 - P2-003
- What was implemented: Created Config namespace for hierarchical config loading and merging
- Files changed: src/config/config.ts (new)
- **Learnings for future iterations:**
  - When exporting both a namespace and a type with the same name, use a type alias (`import { Config as ConfigType }`)
  - Re-export the type with `export type { ConfigType as Config }` for consumers
  - deepMerge function handles nested objects recursively, arrays are replaced not merged
  - Config precedence: defaults < global (~/.dadgpt/config.json) < project (./dadgpt.config.json) < env vars
  - Environment variables supported: DADGPT_PROVIDER, DADGPT_MODEL
  - Config is cached until invalidate() is called
---

## 2026-01-13 - P2-004
- What was implemented: Created XState goal lifecycle state machine
- Files changed: src/state/goal.machine.ts (new)
- **Learnings for future iterations:**
  - State machines go in src/state/ directory
  - XState v5 uses createMachine with types: {} as { context: T, events: E } for type inference
  - Use assign() from xstate for action creators that update context
  - Final states declared with type: "final"
  - Progress clamping: Math.min(100, Math.max(0, value)) ensures 0-100 range
  - createGoalContext() helper provides default values for partial input
---

## 2026-01-13 - P2-005
- What was implemented: Created comprehensive unit tests for the goal state machine
- Files changed: test/unit/state/goal.machine.test.ts (new)
- **Learnings for future iterations:**
  - State machine tests go in test/unit/state/ directory
  - XState v5 uses `createActor(machine, { snapshot: machine.resolveState({ value, context }) })` to test with specific context
  - Use `goalMachine.resolveState()` to create a valid snapshot with custom context
  - Final states cause the actor to stop - sending events to them logs warnings but doesn't throw
  - Mock Date.now with vi.spyOn(Date, "now") for consistent test results
  - Always call actor.stop() in tests to clean up
---

## 2026-01-13 - P2-006
- What was implemented: Created XState todo lifecycle state machine
- Files changed: src/state/todo.machine.ts (new)
- **Learnings for future iterations:**
  - Todo state machine follows same patterns as goal machine
  - TodoState includes 6 states: pending, in_progress, blocked, deferred, done, cancelled
  - Unlike goal machine, done and cancelled are NOT final states (can REOPEN)
  - BLOCK event stores blockedBy ID in context, UNBLOCK clears it to null
  - DEFER event stores the until date in dueDate field
  - Can COMPLETE directly from pending state (useful for quick tasks)
---

## 2026-01-13 - P2-007
- What was implemented: Created comprehensive unit tests for the todo state machine
- Files changed: test/unit/state/todo.machine.test.ts (new)
- **Learnings for future iterations:**
  - Todo machine tests follow same patterns as goal machine tests
  - Use todoMachine.resolveState() to create a snapshot with custom context for testing specific states
  - Todo done/cancelled states are NOT final (status remains "active") unlike goal's completed/abandoned states
  - 21 tests cover all state transitions, BLOCK/UNBLOCK, DEFER, REOPEN, and context validation
  - Test that events only work from appropriate states (e.g., BLOCK only from in_progress)
---

## 2026-01-13 - P2-008
- What was implemented: Created XState project lifecycle state machine
- Files changed: src/state/project.machine.ts (new)
- **Learnings for future iterations:**
  - Project state machine follows same patterns as goal and todo machines
  - ProjectState includes 5 states: planning, active, on_hold, completed, cancelled
  - Unlike todo machine, completed and cancelled ARE final states (like goal machine)
  - ADD_MILESTONE can be called from both planning and active states
  - COMPLETE_MILESTONE only available in active state
  - Status field in context is updated alongside state transitions for consistency
  - createProjectContext() helper follows same pattern as goal/todo
---

## 2026-01-13 - P3-001
- What was implemented: Created grayscale theme system for TUI
- Files changed: src/tui/theme.ts (new)
- **Learnings for future iterations:**
  - TUI components go in src/tui/ directory
  - Theme exports individual objects (text, status, ui, styles, box, dimBox) and combined theme object
  - Uses chalk library for terminal colors (not Ink's color props)
  - Box drawing characters stored as plain strings, dimmed versions use chalk.dim()
  - Style functions (chalk.bold.white, etc.) can be composed for semantic styles
---

## 2026-01-13 - P3-002
- What was implemented: Created ASCII art header component for TUI
- Files changed: src/tui/components/Header.tsx (new)
- **Learnings for future iterations:**
  - React Ink components go in src/tui/components/ directory
  - Use React.ReactElement as return type for Ink components with TypeScript
  - Ink uses color prop directly on Text (e.g., color="blueBright") not chalk
  - ASCII art in multiline strings needs .trim() to remove leading/trailing newlines
  - Box component's flexDirection="column" is useful for vertical layouts
  - marginTop/marginBottom props for spacing between elements
---

## 2026-01-13 - P3-003
- What was implemented: Created InputBox component for user text input
- Files changed: src/tui/components/InputBox.tsx (new)
- **Learnings for future iterations:**
  - ink-text-input provides TextInput component as default export
  - TextInput uses onSubmit callback that receives the submitted value
  - borderStyle="round" gives rounded corners, borderColor="gray" sets border color
  - focus prop on TextInput controls whether it accepts keyboard input
  - When disabled, change placeholder text to indicate waiting state
---

## 2026-01-13 - P3-004
- What was implemented: Created MessageBubble component for chat messages
- Files changed: src/tui/components/MessageBubble.tsx (new)
- **Learnings for future iterations:**
  - MessageBubble props: role ('user' | 'assistant'), content, timestamp (optional)
  - User messages show "You" in blueBright, assistant shows "DadGPT" in gray
  - Use dimColor prop on Text for dim gray timestamp styling
  - wrap="wrap" on Text ensures content wraps properly in terminal
  - toLocaleTimeString with options {hour: "2-digit", minute: "2-digit"} for clean time formatting
---

## 2026-01-13 - P3-005
- What was implemented: Created ChatView component for displaying conversation history
- Files changed: src/tui/components/ChatView.tsx (new)
- **Learnings for future iterations:**
  - ChatView renders MessageBubble for each message in the messages array
  - Empty state shows gray text: "Start a conversation by typing a message below."
  - Loading indicator uses inline LoadingSpinner component with braille animation frames
  - Spinner uses useState + useEffect with setInterval for animation (80ms interval)
  - flexGrow={1} on outer Box allows component to expand to fill available space
  - Export Message interface for use by parent components
---

## 2026-01-13 - P3-006
- What was implemented: Created standalone reusable Spinner component for loading states
- Files changed: src/tui/components/Spinner.tsx (new)
- **Learnings for future iterations:**
  - Spinner uses 10 braille characters: ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]
  - Animation interval of 80ms provides smooth rotation effect
  - useEffect cleanup function with clearInterval prevents memory leaks on unmount
  - Standalone Spinner component can be imported and reused in other components (ChatView has inline version)
  - Use constants (SPINNER_FRAMES, ANIMATION_INTERVAL) for maintainability
---

## 2026-01-13 - P3-007
- What was implemented: Created ToolCall component for displaying tool execution status in TUI
- Files changed: src/tui/components/ToolCall.tsx (new)
- **Learnings for future iterations:**
  - ToolStatus type: "pending" | "running" | "completed" | "error"
  - Status icons mapped via Record<ToolStatus, string>: pending (○), running (◐), completed (●), error (✗)
  - Color mapping also via Record<ToolStatus, string> for type-safe status color lookup
  - Use borderStyle="single" for tool call boxes (vs "round" for input boxes)
  - Truncate helper function keeps UI clean: input truncated to 60 chars, output to 100 chars
  - Only show output when status === "completed", only show error when status === "error"
---

## 2026-01-13 - P3-008
- What was implemented: Created useSession hook for managing chat sessions in TUI
- Files changed: src/tui/hooks/useSession.ts (new)
- **Learnings for future iterations:**
  - React hooks go in src/tui/hooks/ directory
  - useSession hook manages session state and message persistence
  - Export Message and Session interfaces for use by other components
  - Messages are sorted by timestamp when loading from storage
  - useCallback is used for addMessage to maintain referential stability
  - Bus.publish is used to notify other parts of the app about session events
  - Storage paths follow pattern: ["sessions", sessionId, "session"] and ["sessions", sessionId, "messages", messageId]
---

## 2026-01-13 - P3-009
- What was implemented: Created useChat hook for AI chat interactions with streaming responses
- Files changed: src/tui/hooks/useChat.ts (new)
- **Learnings for future iterations:**
  - useChat hook handles AI streaming responses using Vercel AI SDK's streamText
  - Returns isLoading, streamingContent, error, and sendMessage
  - Import { streamText, type CoreMessage } from "ai" for AI SDK streaming
  - Use @ai-sdk/anthropic and @ai-sdk/openai for provider-specific model initialization
  - anthropic(model) and openai(model) create the language model instances
  - sendMessage loads all messages from storage (already saved by useSession) before sending to LLM
  - Use for await...of loop to iterate over result.textStream for streaming chunks
  - Clear streamingContent after saving assistant message to avoid duplicate display
  - Prefix unused parameters with underscore (_content) to satisfy eslint no-unused-vars rule
---

## 2026-01-13 - P3-010
- What was implemented: Created useKeyboard hook for keyboard shortcuts in TUI
- Files changed: src/tui/hooks/useKeyboard.ts (new)
- **Learnings for future iterations:**
  - useKeyboard is a side-effect only hook that returns void (not an object)
  - Uses Ink's useInput hook for keyboard handling and useApp hook for exit function
  - Ctrl+C check: key.ctrl && input === "c"
  - Escape check: key.escape (boolean property on key object)
  - Ink's useApp() provides the exit() function to cleanly exit the application
---

## 2026-01-13 - P3-011
- What was implemented: Created main App component that composes all TUI elements
- Files changed: src/tui/App.tsx (new)
- **Learnings for future iterations:**
  - App component is the main composition point for Header, ChatView, and InputBox
  - Uses useRef to track if initialMessage has been sent (prevents double-sending)
  - Import Config type explicitly: `import { Config, type Config as ConfigType }`
  - Combine stored messages with streamingContent for displayMessages array
  - Use flexDirection="column" and height="100%" for full-height layout
  - overflow="hidden" on the chat container to handle scrolling properly
  - Disable input (disabled prop) while isLoading to prevent user input during AI response
---

## 2026-01-13 - P4-001
- What was implemented: Created model definitions for supported LLM providers
- Files changed: src/provider/models.ts (new)
- **Learnings for future iterations:**
  - Provider files go in src/provider/ directory
  - ModelInfo interface defines: id, name, provider, contextWindow, maxOutput
  - MODELS is a Record<string, ModelInfo> for easy lookup by model ID
  - getModelInfo(modelId) helper function returns ModelInfo or undefined
  - Supported models: claude-sonnet-4-20250514, claude-3-5-haiku-20241022, gpt-4o, gpt-4o-mini
---

## 2026-01-13 - P4-002
- What was implemented: Created Provider namespace for unified LLM provider abstraction
- Files changed: src/provider/provider.ts (new)
- **Learnings for future iterations:**
  - Use createAnthropic() and createOpenAI() from AI SDK to create provider instances with custom API keys
  - API key is passed to provider constructor, not to model settings (e.g., `createAnthropic({ apiKey })`)
  - Provider.getModel() is async because it loads config to get API keys
  - API key resolution order: config.providers[id].apiKey > environment variable
  - LanguageModelV1 is the correct type for AI SDK language models
  - Provider namespace exports listProviders(), isSupported(), getProviderInfo() utility functions
---

## 2026-01-13 - P4-003
- What was implemented: Created tool system types and interfaces
- Files changed: src/tool/types.ts (new)
- **Learnings for future iterations:**
  - Tool files go in src/tool/ directory
  - Tool interface is generic over TParams (Zod schema): `Tool<TParams extends z.ZodTypeAny>`
  - Use `import type { z }` for type-only imports from zod
  - ToolContext provides session context (sessionId, userId?) to tool execution
  - ToolResult returns structured output (title, output, metadata?)
  - ToolExecution tracks execution state with status, timing, and error information
---

## 2026-01-13 - P4-004
- What was implemented: Created ToolRegistry namespace for central tool management
- Files changed: src/tool/registry.ts (new)
- **Learnings for future iterations:**
  - ToolRegistry follows same namespace pattern as Log, Storage, Bus modules
  - getToolsForAI() returns Record<string, AITool> format for Vercel AI SDK streamText/generateText
  - AI SDK expects tools as Record with `parameters` (Zod schema), `description`, and `execute` function
  - formatToolResult() converts ToolResult to string format for AI consumption
  - Auto-registration of default tools deferred until tool implementations exist (P4-005+)
  - Added has() and clear() utility methods for checking tool existence and testing
---

## 2026-01-13 - P4-005
- What was implemented: Created Goal Tool with full CRUD operations and state machine integration
- Files changed: src/tool/goal.ts (new)
- **Learnings for future iterations:**
  - Tools follow Tool<TParams> interface from src/tool/types.ts
  - Store goals with StoredGoal interface that extends GoalContext with state field
  - Use createTimestampedId(prefix) for readable IDs like "goal_01HXYZ..."
  - Goals are stored at ["goals", id] path in storage
  - XState createActor with goalMachine.resolveState() to resume from stored state
  - Bus.publish for goal.created, goal.updated, goal.completed, goal.deleted events
  - Action parameter is an enum allowing list, create, get, update, transition, delete
  - Transition action handles state machine events including COMPLETE_MILESTONE with milestoneId
  - Check for final states (completed/abandoned) before attempting transitions
---

## 2026-01-13 - P4-006
- What was implemented: Created comprehensive unit tests for the Goal Tool
- Files changed: test/unit/tool/goal.test.ts (new)
- **Learnings for future iterations:**
  - Tool tests go in test/unit/tool/ directory
  - Create ToolContext mock: `const mockCtx: ToolContext = { sessionId: "test-session" }`
  - Use DADGPT_DATA_DIR env var override for test isolation
  - Clear Bus.clear() in beforeEach to reset event handlers between tests
  - Use vi.fn() to spy on Bus events: `Bus.subscribe("goal.created", handler)`
  - Goal tool returns metadata with goalId for create operations
  - Access stored goal data via metadata?.goal in get action results
  - Test state machine transitions by chaining transition actions (START, PAUSE, RESUME, COMPLETE)
  - 28 tests cover: create (required/all fields), list (filters), get, update, transition, delete
---

## 2026-01-13 - P4-007
- What was implemented: Created Todo Tool with full CRUD operations and state machine integration
- Files changed: src/tool/todo.ts (new)
- **Learnings for future iterations:**
  - Todo Tool follows same patterns as Goal Tool (StoredTodo extends TodoContext with state field)
  - Todos are stored at ["todos", id] path in storage
  - Uses createTimestampedId("todo") for readable IDs like "todo_01HXYZ..."
  - List action sorts by priority (high > medium > low) then by dueDate (earliest first, nulls last)
  - Priority icons in list: high="!!!", medium="!!", low="!"
  - Complete action is a shortcut that only works from pending or in_progress states
  - BLOCK event requires blockedBy parameter, DEFER event requires until (date) parameter
  - Unlike goal, todo states (done, cancelled) are NOT final - can REOPEN back to pending
  - Transition checks if state actually changed and returns "No Change" if event was invalid
  - Bus events: todo.created, todo.completed, todo.deleted
---

## 2026-01-13 - P4-008
- What was implemented: Created comprehensive unit tests for the Todo Tool
- Files changed: test/unit/tool/todo.test.ts (new)
- **Learnings for future iterations:**
  - Todo Tool tests follow same patterns as Goal Tool tests (mock context, temp dir, Bus.clear())
  - 32 tests cover: create (required/all fields, default priority), list (filters: status, priority, tag; sorting), get, complete shortcut, transitions (block/unblock, defer, reopen, cancel), delete
  - Complete action returns "Already Complete" if todo is done, and "Error" if trying to complete from blocked state
  - Invalid transitions return "No Change" title with message explaining why (unlike Goal which has final states check)
  - Test sorting by verifying position of items in output string using indexOf()
  - Use vi.fn() to spy on Bus events for todo.created, todo.completed, todo.deleted
---

## 2026-01-13 - P4-009
- What was implemented: Created Project Tool with full CRUD operations and state machine integration
- Files changed: src/tool/project.ts (new), src/bus/bus.ts (updated with project events)
- **Learnings for future iterations:**
  - Project Tool follows same patterns as Goal and Todo tools (StoredProject extends ProjectContext with state field)
  - Projects are stored at ["projects", id] path in storage
  - Uses createTimestampedId("project") for readable IDs like "project_01HXYZ..."
  - Actions: list, create, get, update, transition, addMilestone, delete
  - addMilestone generates milestone ID using createTimestampedId("milestone")
  - Project states: planning, active, on_hold, completed, cancelled (completed/cancelled are final)
  - ADD_MILESTONE works from both planning and active states
  - COMPLETE_MILESTONE only works from active state
  - Bus events added: project.created, project.updated, project.completed, project.deleted
---

## 2026-01-13 - P4-010
- What was implemented: Created comprehensive unit tests for the Project Tool
- Files changed: test/unit/tool/project.test.ts (new)
- **Learnings for future iterations:**
  - Project Tool tests follow same patterns as Goal and Todo tool tests (mock context, temp dir, Bus.clear())
  - 35 tests cover: create (required/all fields), list (filters: status; shows budget and milestone progress), get (with/without milestones), addMilestone (with/without due date, error cases), transition (through states, COMPLETE_MILESTONE, invalid transitions), update (fields, events), delete
  - addMilestone returns milestoneId in metadata for subsequent COMPLETE_MILESTONE operations
  - Cannot add milestone or transition from final states (completed/cancelled)
  - List output includes budget when present and milestone progress (e.g., "0/2 milestones")
  - Use vi.fn() to spy on Bus events for project.created, project.updated, project.completed, project.deleted
---
